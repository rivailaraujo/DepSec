package com.rivail.services

import com.rivail.models.Vulnerability
import com.rivail.models.VulnerabilityReport
import com.vdurmont.semver4j.Semver
import groovy.json.JsonOutput
import groovy.json.JsonSlurper
import io.micronaut.context.annotation.Value
import io.micronaut.http.HttpRequest
import io.micronaut.http.client.HttpClient
import io.micronaut.http.client.annotation.Client
import jakarta.inject.Singleton
import org.slf4j.Logger
import org.slf4j.LoggerFactory

@Singleton
class VulnerabilityScannerService {

    private static final Logger LOG = LoggerFactory.getLogger(VulnerabilityScannerService)

    private static final String CONTENT_TYPE_JSON = "application/json"
    private static final String USER_AGENT = "MyVulnerabilityScanner/1.0"
    private static final String HEADER_AUTH = "Authorization"
    private static final String HEADER_CONTENT_TYPE = "Content-Type"
    private static final String HEADER_USER_AGENT = "User-Agent"

    private final HttpClient sonatypeClient
    private final HttpClient githubClient

    private final String githubToken
    private final String username
    private final String token
    private String authHeader

    VulnerabilityScannerService(@Client("https://ossindex.sonatype.org") HttpClient sonatypeClient,
                                @Client("https://api.github.com") HttpClient githubClient,
                                @Value("\${github.token}") String githubToken,
                                @Value("\${sonatype.username}") String username,
                                @Value("\${sonatype.token}") String token) {
        this.sonatypeClient = sonatypeClient
        this.githubClient = githubClient
        this.githubToken = githubToken
        this.username = username
        this.token = token
        initAuthHeader()
    }

    private void initAuthHeader() {
        try {
            String auth = "${username}:${token}"
            authHeader = "Basic " + Base64.getEncoder().encodeToString(auth.getBytes("UTF-8"))
        } catch (Exception e) {
            LOG.error("Falha ao gerar authHeader: {}", e.message, e)
        }
    }

    Map<String, Object> fetchSonatypeVulnerabilities(String packageName, String version) {
        try {
            List<String> coordinates = ["pkg:npm/${packageName}@${version}"]
            Map<String, Object> requestBody = [coordinates: coordinates]

            HttpRequest request = buildPostRequest("/api/v3/component-report", JsonOutput.toJson(requestBody), authHeader)
            String response = sonatypeClient.toBlocking().retrieve(request)
            List data = new JsonSlurper().parseText(response)

            return data ? data[0] : [:]

        } catch (Exception e) {
            LOG.error("Erro na análise Sonatype: {}", e.message, e)
            return [:]
        }
    }

    Map<String, Object> fetchGithubVulnerabilities(String packageName) {
        try {
            String query = """
                query {
                  securityVulnerabilities(ecosystem: NPM, package: "${packageName}", first: 100) {
                    nodes {
                      advisory {
                        ghsaId
                        summary
                        description
                        severity
                        publishedAt
                        references { url }
                      }
                      vulnerableVersionRange
                      firstPatchedVersion { identifier }
                    }
                  }
                }
            """

            Map<String, String> requestBody = [query: query]
            HttpRequest request = buildPostRequest("/graphql", JsonOutput.toJson(requestBody), "bearer ${githubToken}")
                    .header(HEADER_USER_AGENT, USER_AGENT)

            String response = githubClient.toBlocking().retrieve(request)
            return new JsonSlurper().parseText(response)

        } catch (Exception e) {
            LOG.error("Erro na análise GitHub: {}", e.message, e)
            return [:]
        }
    }

    static VulnerabilityReport combineResults(Map<String, Object> sonatypeResult, Map<String, Object> githubResult, String packageName, String version) {
        Map<String, Vulnerability> vulnMap = mapSonatypeResults(sonatypeResult.vulnerabilities)

        mergeGithubIntoSonatype(vulnMap, githubResult?.data?.securityVulnerabilities?.nodes ?: [], version)

        return new VulnerabilityReport(packageName: "${packageName}@${version}", vulnerabilities: vulnMap.values().toList())
    }

    private static Map<String, Vulnerability> mapSonatypeResults(List vulnerabilities) {
        Map<String, Vulnerability> vulnMap = [:]
        vulnerabilities?.each { vuln ->
            if (vuln.id) {
                vulnMap[vuln.id.toString()] = new Vulnerability(id: vuln.id.toString(),
                        displayName: vuln.id.toString(),
                        title: vuln.title,
                        description: vuln.description,
                        severity: vuln.severity,
                        cvssScore: vuln.cvssScore as Double,
                        cvssVector: vuln.cvssVector,
                        cwe: vuln.cwe,
                        cve: vuln.cve,
                        reference: vuln.reference,
                        externalReferences: (vuln.externalReferences instanceof List) ? vuln.externalReferences : [])
            }
        }
        return vulnMap
    }

    private static void mergeGithubIntoSonatype(Map<String, Vulnerability> vulnMap, List githubNodes, String version) {
        githubNodes.each { node ->
            String githubId = node.advisory?.ghsaId?.toString()
            if (!githubId) return

            String range = node.vulnerableVersionRange?.toString()
            if (!isVersionVulnerable(version, range)) return

            List<String> githubRefs = node.advisory.references*.url.findAll { it }

            Vulnerability matchingSonatype = vulnMap.find { entry -> githubRefs.any { ref -> ref.contains(entry.key) }
            }?.value

            if (matchingSonatype) {
                matchingSonatype.externalReferences = (matchingSonatype.externalReferences + githubRefs).unique()
            } else {
                vulnMap[githubId] = new Vulnerability(id: githubId,
                        displayName: githubId,
                        title: node.advisory.summary,
                        description: node.advisory.description,
                        severity: node.advisory.severity,
                        cvssScore: null,
                        cvssVector: null,
                        cwe: null,
                        cve: null,
                        reference: githubRefs.join(", "),
                        externalReferences: githubRefs)
            }
        }
    }

    static boolean isVersionVulnerable(String version, String vulnerableRange) {
        try {
            Semver semver = new Semver(version, Semver.SemverType.NPM)
            return semver.satisfies(vulnerableRange)
        } catch (Exception e) {
            return false
        }
    }

    private HttpRequest buildPostRequest(String path, String body, String auth) {
        return HttpRequest.POST(path, body)
                .header(HEADER_CONTENT_TYPE, CONTENT_TYPE_JSON)
                .header(HEADER_AUTH, auth)
    }
}
